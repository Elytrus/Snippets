// This is a min segment tree

const int MAX = 30001;
int n, 
	arr[MAX], tree[MAX * 6], lazyp[MAX * 12]; // Large arbitrary coefficients to account for O(nlogn) size

// Resolves whatever lazy propogation was done at tree index `i` and pushes it onto its children
inline void resolve_lazy(int i){
	if(lazyp[i]){
		tree[i] = max(0, tree[i] + lazyp[i]);

		lazyp[i << 1] += lazyp[i];
		lazyp[i << 1 | 1] += lazyp[i];
		lazyp[i] = 0;
	}
}

// Example: `build(1, 1, n);`
int build(int i, int l, int r){
	if(l == r) return tree[i] = arr[l];

	int mid = (l + r) / 2;
	return tree[i] = min(build(i << 1, l, mid), build(i << 1 | 1, mid + 1, r));
}

// Example: (from range `a` to `b`) `query(1, 1, n, a, b);`
int query(int i, int bl, int br, int ql, int qr){
	resolve_lazy(i);
	if(br < ql || bl > qr) return INT_MAX;
	if(bl >= ql && br <= qr) return tree[i];

	int mid = (bl + br) / 2;
	return min(query(i << 1, bl, mid, ql, qr), query(i << 1 | 1, mid + 1, br, ql, qr));
}

// Example: (for range `a` to `b` with value `v`) `query(1, 1, n, a, b, v);`
int update(int i, int bl, int br, int ql, int qr, int v){
	resolve_lazy(i);
	if(br < ql || bl > qr) return tree[i];

	if(bl >= ql && br <= qr){
		lazyp[i << 1] += v;
		lazyp[i << 1 | 1] += v;

		return tree[i] = max(0, tree[i] + v);
	}

	int mid = (bl + br) / 2;

	return tree[i] = min(update(i << 1, bl, mid, ql, qr, v), update(i << 1 | 1, mid + 1, br, ql, qr, v));
}
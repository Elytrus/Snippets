const int MAX = 6001, B_MAX = 18;
int dist[MAX];
ll distt[MAX];

int sptable[B_MAX][MAX + 1];
vector<ed> matrix[MAX]; // Adjecency Matrix

int query(int a, int b){ // Querys nodes `a` and `b`
	// Checking if they are the same
	if(a == b){
		return a;
	}

	if(dist[a] > dist[b]){
		swap(a, b);
	}

	// Equalizing levels
	int delta = dist[b] - dist[a];
	for (int i = B_MAX - 1; i >= 0; --i) {
		if(delta & (1 << i)){
			b = sptable[i][b];
		}
	}

	// Checking if they are the same again now that levels are equal
	if(a == b){
		return a;
	}

	// Moving up the chain
	for(int i = B_MAX - 1; i >= 0; --i){
		if(sptable[i][a] != sptable[i][b] && sptable[i][a] != -1 && sptable[i][b] != -1){
			a = sptable[i][a];
			b = sptable[i][b];
		}
	}

	return sptable[0][a];
}

// DFS
void dfs(int curr, int lvl, ll dis, int parent){
	dist[curr] = lvl;
	distt[curr] = dis;
	sptable[0][curr] = parent;

	for(ed adj : matrix[curr]){
		if(adj.v != parent){
			dfs(adj.v, lvl + 1, dis + adj.w, curr);
		}
	}
}

void build(){
	// DFS to build first parents and arrays
	dfs(1, 0, 0, -1);

	// Building sparse table
	for (int i = 1; i < B_MAX; ++i) {
		for (int j = 1; j <= n; ++j) {
			int directpar = sptable[i - 1][j];

			if(directpar != -1){
				sptable[i][j] = sptable[i - 1][directpar];
			}
			else{
				sptable[i][j] = -1;
			}
		}
	}
}